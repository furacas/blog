---
title: moviepy竖屏转横屏
urlname: ul899l
date: '2022-07-20 16:37:53 +0800'
tags: []
categories: []
---

> python、moviepy

本文已废弃，moviepy 效率真是太慢了，推荐使用 ffmpeg

## 解决思路

解决思路的本质还是 resize，不是简单的调整大小。
1 . 将视频放大，可以填满屏幕并做模糊处理；
2 . 将视频缩小，居中位置展示；
将 1.2 合并

效果如图
![image.png](https://cdn.nlark.com/yuque/0/2022/png/328252/1658308404730-6588cd24-342a-45f9-94e3-391d191634c1.png#clientId=u1447ede4-8882-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=734&id=uaf1c46ef&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1468&originWidth=2472&originalType=binary∶=1&rotation=0&showTitle=false&size=2075952&status=done&style=none&taskId=u2eaece0a-7ed7-40d7-b4cc-2968c126db5&title=&width=1236)

## 代码实现

```python
from moviepy.editor import *
from skimage.filters import _gaussian


def blur(image):
    return _gaussian.gaussian(image.astype(float), sigma=30)

src = "test.mp4"

# 读取待转换的视频
clip1 = VideoFileClip(src)

# 将视频放大并加蒙版遮罩
tempClip2 = VideoFileClip(src, audio=False, has_mask="True").resize(4)
clip2 = tempClip2.fl_image(blur)

# 将小的视频叠在大视频的居中位置
temp = CompositeVideoClip([clip2, clip1.set_pos("center")])

# 对叠好的视频进行剪切
final = temp.crop(x1=0, x2=clip2.w, y1=(clip2.h - clip1.h) / 2, y2=clip1.h + (clip2.h - clip1.h) / 2)

# 输出编辑完成的视频
final.resize(height=clip1.h).write_videofile("./target.mp4", audio_codec="aac")
```
